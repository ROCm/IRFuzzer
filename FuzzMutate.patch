diff --git a/llvm/include/llvm/FuzzMutate/OpDescriptor.h b/llvm/include/llvm/FuzzMutate/OpDescriptor.h
index 847f975571bc..dcac83945502 100644
--- a/llvm/include/llvm/FuzzMutate/OpDescriptor.h
+++ b/llvm/include/llvm/FuzzMutate/OpDescriptor.h
@@ -117,6 +117,34 @@ static inline SourcePred anyIntType() {
   return {Pred, Make};
 }
 
+static inline SourcePred anyIntOrVecIntType() {
+  auto Pred = [](ArrayRef<Value *>, const Value *V) {
+    Type *Ty = V->getType();
+    if (VectorType *VecTy = dyn_cast<VectorType>(Ty)) {
+      Ty = VecTy->getElementType();
+    }
+    return Ty->isIntegerTy();
+  };
+  auto Make = None;
+  return {Pred, Make};
+}
+
+static inline SourcePred boolOrVecBoolType() {
+  auto Pred = [](ArrayRef<Value *>, const Value *V) {
+    Type *Ty = V->getType();
+    if (VectorType *VecTy = dyn_cast<VectorType>(Ty)) {
+      Ty = VecTy->getElementType();
+    }
+    if (IntegerType *IntTy = dyn_cast<IntegerType>(Ty)) {
+      return IntTy->getBitWidth() == 1;
+    } else {
+      return false;
+    }
+  };
+  auto Make = None;
+  return {Pred, Make};
+}
+
 static inline SourcePred anyFloatType() {
   auto Pred = [](ArrayRef<Value *>, const Value *V) {
     return V->getType()->isFloatingPointTy();
@@ -125,6 +153,18 @@ static inline SourcePred anyFloatType() {
   return {Pred, Make};
 }
 
+static inline SourcePred anyFloatOrVecFloatType() {
+  auto Pred = [](ArrayRef<Value *>, const Value *V) {
+    Type *Ty = V->getType();
+    if (VectorType *VecTy = dyn_cast<VectorType>(Ty)) {
+      Ty = VecTy->getElementType();
+    }
+    return Ty->isFloatingPointTy();
+  };
+  auto Make = None;
+  return {Pred, Make};
+}
+
 static inline SourcePred anyPtrType() {
   auto Pred = [](ArrayRef<Value *>, const Value *V) {
     return V->getType()->isPointerTy() && !V->isSwiftError();
@@ -203,6 +243,58 @@ static inline SourcePred matchFirstType() {
   return {Pred, Make};
 }
 
+static inline SourcePred matchFirstLengthWAnyType() {
+  auto Pred = [](ArrayRef<Value *> Cur, const Value *V) {
+    assert(!Cur.empty() && "No first source yet");
+    Type *This = V->getType(), *First = Cur[0]->getType();
+    VectorType *ThisVec = dyn_cast<VectorType>(This),
+               *FirstVec = dyn_cast<VectorType>(First);
+    if (ThisVec != nullptr && FirstVec != nullptr) {
+      return ThisVec->getElementCount() == FirstVec->getElementCount();
+    } else {
+      return (ThisVec == nullptr) && (FirstVec == nullptr) &&
+             (!This->isVoidTy());
+    }
+  };
+  auto Make = [](ArrayRef<Value *> Cur, ArrayRef<Type *> BaseTypes) {
+    assert(!Cur.empty() && "No first source yet");
+    std::vector<Constant *> Result;
+    ElementCount EC;
+    bool isVec = false;
+    if (VectorType *VecTy = dyn_cast<VectorType>(Cur[0]->getType())) {
+      EC = VecTy->getElementCount();
+      isVec = true;
+    }
+    for (Type *T : BaseTypes) {
+      // We don't do nested vectors yet.
+      if (!T->isVectorTy() && !T->isVoidTy()) {
+        if (isVec) {
+          // If the first pred is <i1 x N>, make the result <T x N>
+          makeConstantsWithType(VectorType::get(T, EC), Result);
+        } else {
+          makeConstantsWithType(T, Result);
+        }
+      }
+    }
+    assert(!Result.empty() && "No potential constants.");
+    return Result;
+  };
+  return {Pred, Make};
+}
+
+/// Match values that have the same type as the first source.
+static inline SourcePred matchSecondType() {
+  auto Pred = [](ArrayRef<Value *> Cur, const Value *V) {
+    assert((Cur.size() > 1) && "No second source yet");
+    return V->getType() == Cur[1]->getType();
+  };
+  auto Make = [](ArrayRef<Value *> Cur, ArrayRef<Type *>) {
+    assert((Cur.size() > 1) && "No second source yet");
+    return makeConstantsWithType(Cur[1]->getType());
+  };
+  return {Pred, Make};
+}
+
 /// Match values that have the first source's scalar type.
 static inline SourcePred matchScalarOfFirstType() {
   auto Pred = [](ArrayRef<Value *> Cur, const Value *V) {
@@ -216,7 +308,7 @@ static inline SourcePred matchScalarOfFirstType() {
   return {Pred, Make};
 }
 
-} // end fuzzerop namespace
-} // end llvm namespace
+} // namespace fuzzerop
+} // namespace llvm
 
 #endif // LLVM_FUZZMUTATE_OPDESCRIPTOR_H
diff --git a/llvm/include/llvm/FuzzMutate/Operations.h b/llvm/include/llvm/FuzzMutate/Operations.h
index 2eb4c38c2aeb..8abed956c4b9 100644
--- a/llvm/include/llvm/FuzzMutate/Operations.h
+++ b/llvm/include/llvm/FuzzMutate/Operations.h
@@ -24,16 +24,20 @@ namespace llvm {
 /// @{
 void describeFuzzerIntOps(std::vector<fuzzerop::OpDescriptor> &Ops);
 void describeFuzzerFloatOps(std::vector<fuzzerop::OpDescriptor> &Ops);
+void describeFuzzerUnaryOperations(std::vector<fuzzerop::OpDescriptor> &Ops);
 void describeFuzzerControlFlowOps(std::vector<fuzzerop::OpDescriptor> &Ops);
 void describeFuzzerPointerOps(std::vector<fuzzerop::OpDescriptor> &Ops);
 void describeFuzzerAggregateOps(std::vector<fuzzerop::OpDescriptor> &Ops);
 void describeFuzzerVectorOps(std::vector<fuzzerop::OpDescriptor> &Ops);
+void describeFuzzerOtherOps(std::vector<fuzzerop::OpDescriptor> &Ops);
 /// @}
 
 namespace fuzzerop {
 
 /// Descriptors for individual operations.
 /// @{
+OpDescriptor selectDescriptor(unsigned Weight);
+OpDescriptor fnegDescriptor(unsigned Weight);
 OpDescriptor binOpDescriptor(unsigned Weight, Instruction::BinaryOps Op);
 OpDescriptor cmpOpDescriptor(unsigned Weight, Instruction::OtherOps CmpOp,
                              CmpInst::Predicate Pred);
@@ -46,8 +50,8 @@ OpDescriptor insertElementDescriptor(unsigned Weight);
 OpDescriptor shuffleVectorDescriptor(unsigned Weight);
 /// @}
 
-} // end fuzzerop namespace
+} // namespace fuzzerop
 
-} // end llvm namespace
+} // namespace llvm
 
 #endif // LLVM_FUZZMUTATE_OPERATIONS_H
diff --git a/llvm/lib/FuzzMutate/IRMutator.cpp b/llvm/lib/FuzzMutate/IRMutator.cpp
index 105f8bc6c522..f325f2586726 100644
--- a/llvm/lib/FuzzMutate/IRMutator.cpp
+++ b/llvm/lib/FuzzMutate/IRMutator.cpp
@@ -89,6 +89,8 @@ std::vector<fuzzerop::OpDescriptor> InjectorIRStrategy::getDefaultOps() {
   describeFuzzerPointerOps(Ops);
   describeFuzzerAggregateOps(Ops);
   describeFuzzerVectorOps(Ops);
+  describeFuzzerUnaryOperations(Ops);
+  describeFuzzerOtherOps(Ops);
   return Ops;
 }
 
@@ -157,8 +159,8 @@ void InstDeleterIRStrategy::mutate(Function &F, RandomIRBuilder &IB) {
   auto RS = makeSampler<Instruction *>(IB.Rand);
   for (Instruction &Inst : instructions(F)) {
     // TODO: We can't handle these instructions.
-    if (Inst.isTerminator() || Inst.isEHPad() ||
-        Inst.isSwiftError() || isa<PHINode>(Inst))
+    if (Inst.isTerminator() || Inst.isEHPad() || Inst.isSwiftError() ||
+        isa<PHINode>(Inst))
       continue;
 
     RS.sample(&Inst, /*Weight=*/1);
diff --git a/llvm/lib/FuzzMutate/OpDescriptor.cpp b/llvm/lib/FuzzMutate/OpDescriptor.cpp
index 67d44be8b699..1c0b9ff87246 100644
--- a/llvm/lib/FuzzMutate/OpDescriptor.cpp
+++ b/llvm/lib/FuzzMutate/OpDescriptor.cpp
@@ -26,8 +26,17 @@ void fuzzerop::makeConstantsWithType(Type *T, std::vector<Constant *> &Cs) {
     Cs.push_back(ConstantFP::get(Ctx, APFloat::getZero(Sem)));
     Cs.push_back(ConstantFP::get(Ctx, APFloat::getLargest(Sem)));
     Cs.push_back(ConstantFP::get(Ctx, APFloat::getSmallest(Sem)));
-  } else
+  } else if (VectorType *VecTy = dyn_cast<VectorType>(T)) {
+    std::vector<Constant *> EleCs;
+    Type *EltTy = VecTy->getElementType();
+    makeConstantsWithType(EltTy, EleCs);
+    ElementCount EC = VecTy->getElementCount();
+    for (Constant *Elt : EleCs) {
+      Cs.push_back(ConstantVector::getSplat(EC, Elt));
+    }
+  } else {
     Cs.push_back(UndefValue::get(T));
+  }
 }
 
 std::vector<Constant *> fuzzerop::makeConstantsWithType(Type *T) {
diff --git a/llvm/lib/FuzzMutate/Operations.cpp b/llvm/lib/FuzzMutate/Operations.cpp
index 7443d49967c5..5c50ffeb0197 100644
--- a/llvm/lib/FuzzMutate/Operations.cpp
+++ b/llvm/lib/FuzzMutate/Operations.cpp
@@ -67,6 +67,11 @@ void llvm::describeFuzzerFloatOps(std::vector<fuzzerop::OpDescriptor> &Ops) {
   Ops.push_back(cmpOpDescriptor(1, Instruction::FCmp, CmpInst::FCMP_TRUE));
 }
 
+void llvm::describeFuzzerUnaryOperations(
+    std::vector<fuzzerop::OpDescriptor> &Ops) {
+  Ops.push_back(fnegDescriptor(1));
+}
+
 void llvm::describeFuzzerControlFlowOps(
     std::vector<fuzzerop::OpDescriptor> &Ops) {
   Ops.push_back(splitBlockDescriptor(1));
@@ -88,6 +93,27 @@ void llvm::describeFuzzerVectorOps(std::vector<fuzzerop::OpDescriptor> &Ops) {
   Ops.push_back(shuffleVectorDescriptor(1));
 }
 
+void llvm::describeFuzzerOtherOps(std::vector<fuzzerop::OpDescriptor> &Ops) {
+  Ops.push_back(selectDescriptor(1));
+  /// TODO: Should've put cmp here.
+}
+
+OpDescriptor llvm::fuzzerop::selectDescriptor(unsigned Weight) {
+  auto buildOp = [](ArrayRef<Value *> Srcs, Instruction *Inst) {
+    return SelectInst::Create(Srcs[0], Srcs[1], Srcs[2], "S", Inst);
+  };
+  return {Weight,
+          {boolOrVecBoolType(), matchFirstLengthWAnyType(), matchSecondType()},
+          buildOp};
+}
+
+OpDescriptor llvm::fuzzerop::fnegDescriptor(unsigned Weight) {
+  auto buildOp = [](ArrayRef<Value *> Srcs, Instruction *Inst) {
+    return UnaryOperator::Create(Instruction::FNeg, Srcs[0], "F", Inst);
+  };
+  return {Weight, {anyFloatOrVecFloatType()}, buildOp};
+}
+
 OpDescriptor llvm::fuzzerop::binOpDescriptor(unsigned Weight,
                                              Instruction::BinaryOps Op) {
   auto buildOp = [Op](ArrayRef<Value *> Srcs, Instruction *Inst) {
@@ -107,13 +133,13 @@ OpDescriptor llvm::fuzzerop::binOpDescriptor(unsigned Weight,
   case Instruction::And:
   case Instruction::Or:
   case Instruction::Xor:
-    return {Weight, {anyIntType(), matchFirstType()}, buildOp};
+    return {Weight, {anyIntOrVecIntType(), matchFirstType()}, buildOp};
   case Instruction::FAdd:
   case Instruction::FSub:
   case Instruction::FMul:
   case Instruction::FDiv:
   case Instruction::FRem:
-    return {Weight, {anyFloatType(), matchFirstType()}, buildOp};
+    return {Weight, {anyFloatOrVecFloatType(), matchFirstType()}, buildOp};
   case Instruction::BinaryOpsEnd:
     llvm_unreachable("Value out of range of enum");
   }
@@ -298,7 +324,7 @@ OpDescriptor llvm::fuzzerop::insertElementDescriptor(unsigned Weight) {
   auto buildInsert = [](ArrayRef<Value *> Srcs, Instruction *Inst) {
     return InsertElementInst::Create(Srcs[0], Srcs[1], Srcs[2], "I", Inst);
   };
-    // TODO: Try to avoid undefined accesses.
+  // TODO: Try to avoid undefined accesses.
   return {Weight,
           {anyVectorType(), matchScalarOfFirstType(), anyIntType()},
           buildInsert};
@@ -313,8 +339,8 @@ static SourcePred validShuffleVectorIndex() {
     auto *Int32Ty = Type::getInt32Ty(Cur[0]->getContext());
     // TODO: It's straighforward to make up reasonable values, but listing them
     // exhaustively would be insane. Come up with a couple of sensible ones.
-    return std::vector<Constant *>{UndefValue::get(
-        VectorType::get(Int32Ty, FirstTy->getElementCount()))};
+    return std::vector<Constant *>{
+        UndefValue::get(VectorType::get(Int32Ty, FirstTy->getElementCount()))};
   };
   return {Pred, Make};
 }